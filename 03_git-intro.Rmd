# Git Version Control Basics

## Save, Stage, Commit

Git does not automatically preserve versions of every "saved" file. When working with Git, you save files as you always do, but this has no impact on the versions that are preserved in the repository. To create a "versions", you must first add saved files to a Staging area and then "Commit" your staged files to the repository. The Commits that you make constituted the versions of files that are preserved in the repository.

![](./img/save_stage_commit.png)

## Creating Your First Repo

Move to your Home directory

```
$ cd ~
```

note: The \$ character represents your command prompt. DO NOT type it into your terminal

Create a new directory for this course module

```
$ cd ~
$ mkdir dsadventures
```

Change to the new directory

```
$ cd dsadventures
```

Put the new directory under version control

```
$ git init
```


## Checking the Status of a Repo

To check the status of a repository use the followign command

```
$ git status
```

## Version of a File

In Gitspeak, we 'commit' if version of a file to the repository to save a copy of the current working version of a file as a version. This is a multi-step process in which we first 'stage' the file to be committed and then 'commit' the file.

STEP 1:  Place the file you want to version into the Staging Area

```
$ git add <filename>
```

*Replace <filename> in the command above with the actual name of the file you want to version.*

STEP 2: Commit Staged Files

```
$ git commit -m 'A detailed comment explaining the nature of the versio being committed. Do not include any apostrophe's in your comment.'
```

## View a History of Your Commits

To get a history of commits

```
$ git log
```

To see commit history with patch data (insertions and deletions) for a specified number of commits

```
$ git log -p -2
```

To see abbreviated stats for the commit history

```
$ git log --stat
```

You can save a copy of your Git log to a text file with the following command:

```
$ git --no-pager log > log.txt
```

## Comparing Commits

```
$ git diff <commit> <commit>
```

## Comparing Files

```
$ git diff <commit> <file>
```

or 

```
$ git diff <commit>:<file> <commit>:<file>
```

## To View an Earlier Commit

```
$ git checkout <commit>
```

To solve Detached Head problem either RESET HEAD as described below or just chekout another branch

```
git checkout <branch>
```

To save this older version as a parallel branch execute

```
$ git checkout -b <new_branch_name
```

This will save the older commit as a new branch running parallel to master.

## Undoing Things

One of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to redo that commit, make the additional changes you forgot, stage them, and commit again using the --amend option

```
$ git commit --amend
```

To unstage a file for commit use

```
$ git reset HEAD <file>
```

Throwing away changes you've made to a file

```
$ git checkout -- <file>
```

Rolling everything back to the last commit

```
$ git reset --hard HEAD
```

Rolling everything back to the next to last commit (The commit before the HEAD commit)

```
$ git reset --hard HEAD^
```

Rolling everything back tp two commits before the head

```
$ git reset --hard HEAD^2
```

Rolling everything back to an identified commit using HASH/ID from log

```
$ git reset --hard <commit>
```


## When Things go Wrong!

To reset everything back to an earlier commit and make sure that the HEAD pointer is pointing to the newly reset HEAD, do the following

```
$ git reset --hard <commit>
$ git reset --soft HEAD@{1}
```

## Git Branching

Branching provides a simple way to maintain multiple, side-by-side versions of the files in a repository.  Conceptually, branching a repository creates a copy of the codebase in its current state that you can work on without affecting the primary version from which it was copied.  This alows you to work down multiple paths without affecting the main (or other) codebase.

![](./img/GIT-Branchand-its-Operations.png)

To see a list of branches in your repository

```
$ git branch
```

To create a new branch

```
$ git checkout -b hotfix
```

New branches are created of the current working branch.  To change branches use

```
$ git checkout <branch name>
```

### Merging Branches

When you merge a branch, git folds any changes that you made to files in an identified branch into the current working branch.  It also adds any new files.  When you perform a merge, a new commit will be automatically created to track the merge.  To merge branches, commit any changes to the branch you want to merge (in this example, the 'hotfix' branch) then checkout the branch into which you want to merge (for example, master), and then execute a merge command.

```
$ git commit -m 'commiting staged files in hotfix branch'
$ git checkout master
$ git merge hotfix

```

### Branching Workflows

There are as many different branching workflows as there are development teams and projects.  However, over the years something approximating an "industry standard" has evolved as follows:
 
1. The "master" or "primary" branch is typically reserved for the current, live and in production version of the codebase.
2. The "development" or "dev" branch holds the current, combined, working version of the code.
3. "topic" branches are created on-the-fly by individuals and are focused on particular coding efforts, one each for each development task.

![](./img/branching_workflows.png)

For example, let's consider a case where there is a team maintaining and developing a company website.  In this case, the "master" branch would contain the version of the code that is currently deployed on the live webserver.  The "dev" branch would contain a testable version of the code that reflects completed changes to the site made by all team members that have yet to be deployed.  Finally, the repository would also contain many topic branches, each of which holds code related to a particular change that was or is being worked on.  For exmaple, a team developing a new widget for visualizing data some area of the site would create a suitably named topic branch (somehting like "viz_widget") for this topic and do all their initial coding in this branch.  Once they have completed and tested their code in this branch, they would merge it into the "dev" branch.  The new code can then be vidwed and tested by others as part of the "dev" branch.  Once all topics branches for planned features for the next release of the website have been merged to "dev" and "dev" has been thoroughly testes (and fixed as necessary), "dev" is then merged into "master" and the "master" branch is then deployed to the live webserver.  
