# Functions

## Learning objectives

After this lecture, you should be able to:

  * explain what a function is
  * read and understand the basic syntax of a function in R
  * use this syntax to call a function
  * use this syntax to build your own function
  * test your function 
  * install packages in R
  * load libraries in R
  
## What is a function?

Why build code several or a hundred times when you can build it once and then call and run it as many times as you want? The answer is, don't! A function allows you to perform an action multiple times in R by calling it and applying it in similar contexts. 

For instance, if you build a function that checks the class of all vectors in a dataframe, you can name this function and then apply it to do the same operation with any other dataframe. Or, if you build a function that graphs the correlation between two numeric vectors and exports this graph to a .png file, you can call this same function and apply it to two other vectors, again and again as needed. Functions can greatly increase the efficiency of your programming, and allow you to create flexible and customized solutions.


## What is the basic syntax of a function in R?

The basic syntax of a function in R, or the way it should be written so that R recognizes it and applies it do perform actions, is usually stated as follows:

```
function_name <- function(argument_1, argument_2, ...) {
   Function body 
}

```

What this does not demonstrate is that there are actually two steps to a function: building it, and applying it. We will look at both steps in the following [code from DataCamp:](https://www.datacamp.com/community/tutorials/functions-in-r-a-tutorial#what)

## Building and calling functions

### Step 1: Building the function  
The code chunk builds the function, setting "myFirstFun" as the name, or variable, to which they have assigned the function. The function itself runs from the word "function" down through the closing curly brace.

```
myFirstFun<-function(n)
{
  # Compute the square of integer `n` 
  n*n  
}
```

**What is an argument?** In the above example, "(n)" is the argument. R looks for this argument (in this case, "n") in the body of the function, which in this case is n*n.

When we run the above script, the function is saved as an object into the global environment so that it can be called elsewhere, as demonstrated in the code chunks below.

*The function has no effect unless you apply it. Until that happens, the function will do nothing but wait to be called.*

### Step 2: Calling the function  

The code chunk below calls "myFirstFun(n)" and tells R to assign the results of the operation the function performs (n*n) to the variable "u". But if we run this code as it is (with "n" in the parentheses), we will get an error (unless we have previously assigned "n" as a variable with a value that will accept the operation to be performed â€” so "n" needs to be a number in this case so that it can be multiplied). We do not actually want to perform the function on the letter "n" but rather, on a number that we will insert in the place of "n."

We can apply this function by setting "n" as a number, such as 2, in the example below.
```
# Call the function with argument `n`
u <- myFirstFun(2)

# Call `u`
u
```

Once we have changed "n" to a number, R then performs this operation and saves the result to a new variable "u". We can then ask R to tell us what "u" is, and R returns or prints the results of the function, which in this case, is the number 4 (2*2).

The image below shows the results we get if we attempt to run the function without changing the argument "n" to a number (giving us an error), and the results when we change "n" to the number "2" which assigns the result of the function (4) to "u", or the number "3" which assigns the result of the function (now 9) to "u". 

![](./img/sample_lec7.png)


It is important to understand that "n" is an **argument** of the function "myFirstFun." R does not consider "n" a variable, but it acts like a variable because it can change as you call the function into different contexts. 
*To R, "u" and "myFirstFun" are variables because they are names to which values and other content are assigned.* 

### Example function with one argument  

**Step 1: Build the function**
In the code below, we will build a function that groups age, as a number, into a category based on conditions we set using an if...else statement.


```{r}
#build function with one argument (variable)
categorize_age <- function(age) {
  if(age < 26){
    category <- "25 and under"
  } else if(age > 25 & age < 56) {
    category <- "26 to 55"
  } else {
    category <- "56 and over"
  }
  return(category)
}
```

**Step 2: Call the function in one or more contexts.**
In the code below, we will call the function we built above and apply it to two different values for age. Just as we saw in the example above where we inserted the numbers 2 or 3 in place of "n", we will insert the values of age we want to use in place of the word "age" to call the new function we have built. 

```{r}
#run check_class function on two different values for age
categorize_age(15)
categorize_age(70)
```

### Example function with more than one argument  

A function works similarly when it has two or more arguments. 

Let's use the class data we collected at the start of term, `my.data`, generated below.

```{r}
pets <- c("woof", "woof", "cat", "woof", "woof", "cat", 
          "woof", "woof", "woof", "woof", "woof")
place <- c("Temple", "Yakitori", "Panera", "Yakitori", "Guads", 
           "Home", "Tea List", "Raising Canes", "Pachamama", 
           "Lazi Cow", "Wok of Flame")
time.min <- c(5, 4, 4, 12, 10, 2, 3, 4, 4, 5, 19)
distance.mi <- c(0.9, 0.6, 0.8, 0.6, 2, 100, 0.6, 0.7, 0.8, 1, 3.7)
major <- c("chicanx studies", "human development", "economics",
           "undeclared", "psychology", "MMM",
           "psychology", "undeclared", "human development", "undeclared", "GG")

my.data <- data.frame(place, distance.mi, time.min, major, pets)
```

Now let's say we only want to look at the first vector or column in the dataframe `my.data`. We would write a line of code that looks like this:

```{r}
my.data[1]
```

But if we wanted to create a function that looks at any column/vector in any dataframe, we could write a function that looks like this:

```{r}
#build function with two arguments (variable)
one_column <- function(data, x) {
  data[x]
}
```
*Note: if we want to tell a user what kind of input we want to include, we could instead do something like function(dataset, column_position) or function(dataset, column_name).*

Once we have run the above function (telling R to save it to the global environment), we would then call this new function, which we have named one_column, and apply it to various dataframes, and telling R which column or vector in each dataframe we want to view.

```{r}
#run one_column function on two different dataframes
one_column(my.data, 1)
one_column(my.data, 2)
```


## Saving functions and sourcing them from another file

You can save the functions you build to a separate file, and then load these in to another script in the future. For example, I can paste the function I wrote above into a new script.

```
#build function with two arguments (variable)
one_column <- function(data, x) {
  data[x]
}
```

Then I could save this script with any file name, typically something like "functions.r". This "functions.r" script can then be loaded into any other script with the `source()` function. To load your pre-saved functions into a new script, you can call the "function.R" file at the top of the new script:

```{r, eval=FALSE}
# Open a new script, then paste and run the following line
source("functions.r") 
```

The above code will allow you to call functions that are saved in these libraries and in the functions.r file.


## Saving functions and calling them from another file

You can save the functions you build to a separate file, and then load these as a source. For example, I might save my functions to an R script, called "functions.r". I can then load these sources along with my packages into my R environment. 

*Note: Although we loaded libraries as we went through this lesson, the best practice is to run your packages and source files at the very beginning of your new R script, as shown in the example that follows.*

```{r, eval=FALSE}
library(dplyr)
library(wakefield)
library(rlang)
library(ggforce)
source("functions.r") 
```

The above code will allow you to call functions that are saved in these libraries and in the functions.r file.
